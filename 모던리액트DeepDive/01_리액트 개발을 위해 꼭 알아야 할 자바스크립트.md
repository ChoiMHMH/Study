# 1장. 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.1.3 자바스크립트의 동등 비교
자바스크립트에서는 비교를 위한 또 한가지 방법인 Object.is 가 있다.
두 개의 인수를 받아, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드이다.
- `==` 비교 : 양쪽이 타입이 다를 시 비교 할 수 있도록 강제 형변환 후 비교
- `===` 비교 : 형변환을 하지 않고 바로 비교
- Object.is 비교 : ===와 비슷하게 형변환 없이 비교하지만, -0, +0 과 같은 비교도 false, 즉 개발자가 좀 더 원하는 방식으로 비교가 가능하다.
  =>하지만 객체 비교는 불가.(주소값)

## 1.1.4 리액트에서의 동등 비교
리액트의 비교는 Object.is로 먼저 비교를 수행한 다음, Object.is에서 수행하지 못하는 비교(객체 간 얕은 비교)를 한 번 더 수행한다.
 => 리액트 팀에서 구현한 shallowEqual은 객체의 1 depth까지는 비교가 가능하다. 그러나 2 depth까지 가면 이를 비교할 방법이 없다.
 
 리액트에서 사용하는 JSX props는 객체이고, props는 일자적으로 비교하면 되기 때문에 이렇게 객체의 얕은 비교까지만 구현하였다.(리액트 개발자가)
 
 **그래서 props에 객체를 넘기면 depth 2를 넘기면 렌더링이 예상치 못하게 작동 할 수 있다.**
  


## 1.4 클로저
호출되는 방식에 따라 결정되는 this와 다르게, 변수가 코드 내부에서 어디에서 선언됐는지(어휘적 환경)에 따라 정적으로 결정된다.
클로저는 이러한 어휘적 환경에 따라 조합하여 코딩하는 기법이다.
### 1.4.2 변수의 유효 범위, 스코프
1. 전역 스코프
2. 함수 스코프
클로저를 사용하는 이유?
- 주로 특정 함수를 통해서만 변경을 허용하고 싶을 때 사용한다.
- 리액트에서 대표적으로 `useState`가 있다.
- 리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근 가능하다.
- useState 호출은 한번으로 끝나지만 `const [state, useState] = useState()` setState는 계속 내부의 최신값(prev)을 알고있다. => 이는 클로저를 활용했기 때문에 가능하다.

클로저의 개념, 외부함수를 기억하고 이를 내부 함수에서 가져다 쓰는 메커니즘은 성능에 영향을 미친다.
- 그러므로 클로저에 꼭필요한 작업만 두고, 클로저 사용을 적절한 스코프로 가둬두어 사용하도록 한다.
- 클로저는 공짜가 아니므로 주의
  
## 1.5 이벤트 루프와 비동기 통신의 이해
#### 이벤트 루프
- 호출 스택에 실행중인 코드가 있는지, 태크스 큐에 대기 중인 함수(외부에서 실행되고 반환된 값= 콜백)가 있는지 반복해서 확인하는 역할.
- 즉 호출 스택이 비고, 콜백이 실행 가능한 때가 오면 이것을 꺼내서 수행하는 역할을 한다.
- 하나의 마이크로 태스크 큐(태스크 큐와 다름) 을 가짐 => 대표적으로 Promise가 있다.
 => 태스크 큐보다 우선권을 갖는다.(즉. setTimeout과 setInterver 은 Promise보다 늦게 실행된다.)

#### 태스크 큐
- 외부 Web API등을 실행은 자바스크립트 외부에서 실행되고 완료된 콜백이 태스크 큐로 들어가는 것

#### 비동기 실행
- fetch를 기반으로 실행되는 네트워크 요청은(비동기작업) 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌, 태스크 큐가 할당되는 별도의 스레드에서 작업.
- 즉 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 Web API등은 자바스크립트 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것.

### 태스크 큐와 마이크로 태스크 큐
- 태스크 큐보다 우선권을 갖는다.(즉. setTimeout과 setInterver 은 Promise보다 늦게 실행된다.)
- 태스크 큐의 대표적인 작업 : setTimeout, setInterval, setImmediate 등
- 마이크로 태스크 큐의 대표적인 작업: process.nextTick, queueMicroTask, MutationObserver
즉 외부 API등의 실행이 마지막에 가져와 질 수 있으므로 await등으로 기다려주는 작업을 해주어야. hydration참고.

## 그렇다면 렌더링은 언제 실행될까?
1. 마이크로 태스크 큐 실행
2. 렌더링
3. 태스크 큐
- 즉 각 마이크로 태스크 큐 작업이 끝날 때마다 한번씩 렌더링 할 기회를 얻는다.
- 브라우저에 렌더링 하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에서 일어나는 것을 알 수 있다.


### 1.6 리액트에서 자주 사용하는 자바스크립트 문법
### 1.7 타입스크립트
#### 1.7.2
- 타입가드를 적극적으로 활용하자
  typeguard: typeof, instanceof, in, is 등을 사용하여 타입을 보장하는 것
언제 무엇을 써야할까?
- typeof: 원시타입을 확인할 때
- instanceof: 클래스의 인스턴스인지 확인할 때
- in: 객체의 key를 확인할 때 => 객체의 key를 확인할 때는 in을 사용하는 것이 좋다.
- is: 커스텀 타입가드를 만들 때
  - 제네릭
    제네릭은 2개 이상의 타입을 제네릭 타입으로 선언할 때 유용하다.
